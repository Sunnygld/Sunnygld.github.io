<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JAVA代码优化]]></title>
      <url>http://gongly.cn/2016/11/02/JAVA%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><a href="http://developer.51cto.com/art/201511/496263.htm" target="_blank" rel="external">原文连接!!!</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码优化，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？</p>
<p>这个问题我是这么考虑 的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。代码优化也是一样，如果项目着眼于尽快无BUG上 线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化 点累积起来，对于代码的运行效率绝对是有提升的。</p>
<a id="more"></a>
<h2 id="代码优化的目标是："><a href="#代码优化的目标是：" class="headerlink" title="代码优化的目标是："></a>代码优化的目标是：</h2><ol>
<li>减小代码的体积</li>
<li>提高代码运行的效率</li>
</ol>
<h2 id="代码优化细节"><a href="#代码优化细节" class="headerlink" title="代码优化细节"></a>代码优化细节</h2><ul>
<li><p>尽量指定类、方法的final修饰符</p>
<p> <strong>带有final修饰符的类是不可派生的。</strong>在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是 final的。为类指定final修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该 类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大，具体参见Java运行期优 化。此举能够使性能平均提高50%。</p>
</li>
<li><p>尽量重用对象</p>
<p> 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p>
</li>
<li><p>尽可能使用局部变量</p>
</li>
</ul>
<p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<ul>
<li>及时关闭流</li>
</ul>
<p>Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p>
<ul>
<li>尽量减少对变量的重复计算</li>
</ul>
<p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) </div><div class="line"> </div><div class="line">&#123;...&#125;</div></pre></td></tr></table></figure>
<p>建议替换为： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> length = list.size(); i &lt; length; i++) </div><div class="line"> </div><div class="line">&#123;...&#125;</div></pre></td></tr></table></figure>
<p>这样，在list.size()很大的时候，就减少了很多的消耗</p>
<ul>
<li>尽量采用懒加载的策略，即在需要的时候才创建</li>
</ul>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"aaa"</span>;<span class="keyword">if</span> (i == <span class="number">1</span>) </div><div class="line">&#123; </div><div class="line"> </div><div class="line">list.add(str); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议替换为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) </div><div class="line">&#123; </div><div class="line"> </div><div class="line">String str = <span class="string">"aaa"</span>; </div><div class="line"> </div><div class="line">list.add(str); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>慎用异常</li>
</ul>
<p>异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方 法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建 了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。</p>
<ul>
<li>不要在循环中使用try…catch…，应该把其放在最外层</li>
</ul>
<p>除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了</p>
<ul>
<li>如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度</li>
</ul>
<p>比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例：</p>
<ol>
<li><p>StringBuilder()// 默认分配16个字符的空间 </p>
</li>
<li><p>StringBuilder(int size)// 默认分配size个字符的空间 </p>
</li>
<li><p>StringBuilder(String str)　// 默认分配16个字符+str.length()个字符空间 </p>
</li>
</ol>
<p>可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如 StringBuilder吧，length表示当前的StringBuilder能保持的字符数量。因为当StringBuilder达到最大容量的时 候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数 组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂 是4096，每次扩容加的2不管，那么：</p>
<ol>
<li>在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间</li>
<li>把原来的4096个字符拷贝到新的的字符数组中去<br>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但 是，注意，像HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为 0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。</li>
</ol>
<ul>
<li><p>当复制大量数据时，使用System.arraycopy()命令</p>
</li>
<li><p>乘法和除法使用移位操作</p>
</li>
</ul>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">a = val * <span class="number">8</span>; </div><div class="line"> </div><div class="line">b = val / <span class="number">2</span>; </div><div class="line"> </div><div class="line">&#125; </div><div class="line">`</div></pre></td></tr></table></figure></p>
<p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">a = val &lt;&lt; <span class="number">3</span>; </div><div class="line"> </div><div class="line">b = val &gt;&gt; <span class="number">1</span>; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p>
<ul>
<li>循环内不要不断创建对象引用</li>
</ul>
<p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">Object obj = <span class="keyword">new</span> Object(); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Object obj = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123; </div><div class="line"></div><div class="line">obj = <span class="keyword">new</span> Object(); </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样的话，内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。</p>
<ul>
<li><p>基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList</p>
</li>
<li><p>尽量使用HashMap、ArrayList、StringBuilder</p>
</li>
</ul>
<p>除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</p>
<ul>
<li>不要将数组声明为public static final</li>
</ul>
<p>因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</p>
<ul>
<li>尽量在合适的场合使用单例</li>
</ul>
<p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>
<ol>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ol>
<p>PS:<a href="http://blog.csdn.net/jason0539/article/details/23297037/" target="_blank" rel="external">对单例的讲解</a></p>
<ul>
<li>尽量避免随意使用静态变量</li>
</ul>
<p>要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的</p>
<p>如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></div><div class="line">&#123; </div><div class="line"> </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B(); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止</p>
<ul>
<li>及时清除不再需要的会话</li>
</ul>
<p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统 会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转 储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的 invalidate()方法清除会话。</p>
<p>PS:在传递对象流的时候就需要对对象流进行序列化,所以说,用GSON的方法或许才是比较好的状态</p>
<ul>
<li>实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历</li>
</ul>
<p>这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改 其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通 for循环效率将高于使用foreach循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess)</div><div class="line">&#123; <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;&#125;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">Iterator&lt;?&gt; iterator = list.iterable(); <span class="keyword">while</span> (iterator.hasNext())&#123;iterator.next()&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。</p>
<ul>
<li>使用同步代码块替代同步方法</li>
</ul>
<p>这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
<ul>
<li>将常量声明为static final，并以大写命名</li>
</ul>
<p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p>
<ul>
<li>不要创建一些不使用的对象，不要导入一些不使用的类</li>
</ul>
<p>这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容</p>
<ul>
<li>程序运行过程中避免使用反射</li>
</ul>
<p>关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制， 特别是Method的invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入 内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。</p>
<ul>
<li>使用数据库连接池和线程池</li>
</ul>
<p>这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程</p>
<ul>
<li>使用带缓冲的输入输出流进行IO操作</li>
</ul>
<p>带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率</p>
<ul>
<li>顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList</li>
</ul>
<p>这个，理解ArrayList和LinkedList的原理就知道了</p>
<p>不要让public方法中有太多的形参</p>
<p>public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p>
<ol>
<li>违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</li>
<li>参数太多势必导致方法调用的出错概率增加，至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体类中，作为insert方法的形参</li>
</ol>
<ul>
<li>字符串变量和字符串常量equals的时候将字符串常量写在前面</li>
</ul>
<p>这是一个比较常见的小技巧了，如果有以下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"123"</span>; </div><div class="line"><span class="keyword">if</span> (str.equals(<span class="string">"123"</span>)) &#123; </div><div class="line"> </div><div class="line">... </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建议修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"123"</span>; </div><div class="line"><span class="keyword">if</span> (<span class="string">"123"</span>.equals(str)) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">... </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这么做主要是可以避免空指针异常</p>
<ul>
<li>请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者</li>
</ul>
<p>平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。<br>在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true</p>
<p>如果有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">2</span>; </div><div class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">... </div><div class="line"> </div><div class="line">&#125;<span class="keyword">else</span>&#123; </div><div class="line"> </div><div class="line">... </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C/C++判断”i==1″不成立，所以以0表示，即false。</p>
<p>但是如果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line"><span class="keyword">if</span> (i = <span class="number">1</span>) &#123;</div><div class="line"> ... </div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"> ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>万一程序员一 个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比较的值是1，应该返回的 false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作</p>
<p>建议将 if语句写为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line"><span class="keyword">if</span> (<span class="number">1</span> == i) &#123;</div><div class="line"> ...</div><div class="line"> &#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"> ... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。<br>但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。</p>
<ul>
<li>不要对数组使用toString()方法</li>
</ul>
<p>看一下对数组使用toString()打印出来的是什么：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"> </div><div class="line">&#123; <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; </div><div class="line"> </div><div class="line">System.out.println(is.toString()); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>结果是：<br>[I@18a992f<br>本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString()没有意义，但是对集合 toString()是可以打印出集合里面的内容的，因为集合的父类AbstractCollections<e>重写了Object的 toString()方法。</e></p>
<ul>
<li>不要对超出范围的基本数据类型做向下强制转型</li>
</ul>
<p>这绝不会得到想要的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line">&#123; </div><div class="line"> </div><div class="line"><span class="keyword">long</span> l = <span class="number">12345678901234L</span>; </div><div class="line"> </div><div class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>)l; </div><div class="line"> </div><div class="line">System.out.println(i); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可能期望得到其中的某几位，但是结果却是：</p>
<p>1942892530</p>
<p>解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p>
<p>0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</p>
<p>一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p>
<p>0111 0011 1100 1110 0010 1111 1111 0010</p>
<p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p>
<ol>
<li>整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是 double，所以定义float的时候要写成””float f = 3.5f”</li>
<li>接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int</li>
</ol>
<ul>
<li>公用的集合类中不使用的数据一定要及时remove掉</li>
</ul>
<p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p>
<ul>
<li>把一个基本数据类型转为字符串，基本数据类型.toString()是最快的方式、String.valueOf(数据)次之、数据+””最慢</li>
</ul>
<p>把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString()、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line"><span class="keyword">int</span> loopTime = <span class="number">50000</span>; </div><div class="line"> </div><div class="line">Integer i = <span class="number">0</span>; <span class="keyword">long</span> startTime = System.currentTimeMillis(); <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">String str = String.valueOf(i); </div><div class="line"> </div><div class="line">&#125; </div><div class="line"> </div><div class="line">System.out.println(<span class="string">"String.valueOf()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>); </div><div class="line"> </div><div class="line">startTime = System.currentTimeMillis(); <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">String str = i.toString(); </div><div class="line"> </div><div class="line">&#125; </div><div class="line"> </div><div class="line">System.out.println(<span class="string">"Integer.toString()："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>); </div><div class="line"> </div><div class="line">startTime = System.currentTimeMillis(); <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; loopTime; j++) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">String str = i + <span class="string">""</span>; </div><div class="line"> </div><div class="line">&#125; </div><div class="line"> </div><div class="line">System.out.println(<span class="string">"i + \"\"："</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>); </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果为：</p>
<p>String.valueOf()：11ms Integer.toString()：5ms i + “”：25ms</p>
<p>所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString()方法。至于为什么，很简单：</p>
<ol>
<li>String.valueOf()方法底层调用了Integer.toString()方法，但是会在调用前做空判断</li>
<li>Integer.toString()方法就不说了，直接调用了</li>
<li>i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString()方法获取字符串</li>
</ol>
<p>三者对比下来，明显是2最快、1次之、3最慢</p>
<ul>
<li>使用最有效率的方式去遍历Map</li>
</ul>
<p>遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">HashMap&lt;String, String&gt; hm = <span class="keyword">new</span> HashMap&lt;String, String&gt;(); </div><div class="line"> </div><div class="line">hm.put(<span class="string">"111"</span>, <span class="string">"222"</span>); </div><div class="line"> </div><div class="line">Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hm.entrySet(); </div><div class="line"> </div><div class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator(); <span class="keyword">while</span> (iter.hasNext()) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">Map.Entry&lt;String, String&gt; entry = iter.next(); </div><div class="line"> </div><div class="line">System.out.println(entry.getKey() + <span class="string">"\t"</span> + entry.getValue()); </div><div class="line"> </div><div class="line">&#125; </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你只是想遍历一下这个Map的key值，那用”Set<string> keySet = hm.keySet();”会比较合适一些</string></p>
<ul>
<li>对资源的close()建议分开操作</li>
</ul>
<p>意思是，比如我有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123; </div><div class="line"> </div><div class="line">XXX.close(); </div><div class="line"> </div><div class="line">YYY.close(); </div><div class="line"> </div><div class="line">&#125;<span class="keyword">catch</span> (Exception e) </div><div class="line"> </div><div class="line">&#123; </div><div class="line"> </div><div class="line">... </div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>建议修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>&#123; </div><div class="line">XXX.close(); </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"> ... </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123; </div><div class="line">YYY.close();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">catch</span> (Exception e) &#123; </div><div class="line">... </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然有些麻烦，却能避免资源泄露。我们想，如果没有修改过的代码，万一XXX.close()抛异常了，那么就进入了cath块中 了，YYY.close()不会执行，YYY这块资源就不会回收了，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为下面的写法之后，就保 证了无论如何XXX和YYY都会被close掉。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM内存分配]]></title>
      <url>http://gongly.cn/2016/11/01/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      <content type="html"><![CDATA[<h2 id="PCR-程序计数器-的了解与机制"><a href="#PCR-程序计数器-的了解与机制" class="headerlink" title="PCR(程序计数器)的了解与机制"></a>PCR(程序计数器)的了解与机制</h2><p><a href="http://www.jianshu.com/p/7ebbe102c1ae" target="_blank" rel="external">原文连接</a></p>
<a id="more"></a>
<p><img src="/img/javaJVM内存非配机制.jpg" alt="javaJVM内存非配机制"></p>
<ul>
<li><p>程序计数器可以看做是当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
</li>
<li><p>由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，程序计数器是<strong>线程私有</strong>的内存区域。</p>
</li>
<li><p>如果线程执行的是一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；<br>如果线程执行的是一个Native方法，计数器的值为空。</p>
</li>
<li><p>Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域。(内存溢出)</p>
</li>
</ul>
<p>Q:什么是NATIVE关键字</p>
<p>A:Java不是完美的，Java的不足除了体现在运行速度上要比传统的C++慢许多之外，Java无法直接访问到操作系统底层（如系统硬件等)，为此Java使用native方法来扩展Java程序的功能。</p>
<p>　　可以将native方法比作Java程序同C程序的接口，其实现步骤：</p>
<p>　　1、在Java中声明native()方法，然后编译。</p>
<p>　　2、用javah产生一个.h文件。</p>
<p>　　3、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）。</p>
<p>　　4、将第三步的.cpp文件编译成动态链接库文件。</p>
<p>　　5、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。</p>
<p>　　JAVA的native方法适用的情况：</p>
<p>　　1、为了使用底层的主机平台的某个特性，而这个特性不能通过JAVA API访问。</p>
<p>　　2、为了访问一个老的系统或者使用一个已有的库，而这个系统或这个库不是用JAVA编写的。</p>
<p>　　3、为了加快程序的性能，而将一段时间敏感的代码作为本地方法实现。</p>
<p><a href="http://blog.csdn.net/funneies/article/details/8949660" target="_blank" rel="external">NATIVE关键字详细使用</a></p>
<h2 id="JAVA虚拟机栈"><a href="#JAVA虚拟机栈" class="headerlink" title="JAVA虚拟机栈"></a>JAVA虚拟机栈</h2><p><img src="/img/JAVA虚拟机栈.png" alt="JAVA虚拟机栈"></p>
<ul>
<li><p>Java虚拟机栈描述的是Java方法执行的内存模型：每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
</li>
<li><p>Java虚拟机栈是线程私有的，它的生命周期与线程相同。</p>
</li>
<li><p>程序员主要关注的stack栈内存，就是虚拟机栈中局部变量表部分。局部变量表存放了编译时期可知的各种<strong>基本数据类型</strong>和<strong>对象</strong>引用。<br>局部变量表所需的内存空间在编译时期完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
</li>
<li><p>Java虚拟机规范对这个区域规定了两种异常情况：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；</li>
<li>如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常；<br>（当前大部分JVM都可以动态扩展，只不过JVM规范也允许固定长度的虚拟机栈）</li>
</ol>
</li>
</ul>
<h2 id="JAVA本地方法栈"><a href="#JAVA本地方法栈" class="headerlink" title="JAVA本地方法栈"></a>JAVA本地方法栈</h2><ul>
<li><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码），而本地方法栈为虚拟机使用到的Native方法服务。</p>
</li>
<li><p>Java虚拟机规范对本地方法栈使用的语言、使用方法与数据结构并没有强制规定，因此可以由虚拟机自由实现。例如：HotSpot虚拟机直接将本地方法栈和虚拟机栈合二为一。</p>
</li>
<li><p>同虚拟机栈相同，Java虚拟机规范对这个区域也规定了两种异常情况StackOverflowError 和 OutOfMemoryError异常。</p>
</li>
</ul>
<h2 id="JAVA堆"><a href="#JAVA堆" class="headerlink" title="JAVA堆"></a>JAVA堆</h2><ul>
<li><p>Java堆是被所有的线程共享的一块内存区域，在虚拟机启动时创建。<br>Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
</li>
<li><p>Java堆是垃圾回收器管理的主要区域，因此也被称为”GC堆”。<br>从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代；<br>从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（TLAB）；<br>不论如何划分，都与存放的内容无关，无论哪个区域，存储的仍然是对象实例。</p>
</li>
<li><p>Java虚拟机规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现上，既可以是固定大小的，也可以是可扩展的，不过当前主流JVM都是按照可扩展来实现的。</p>
</li>
<li><p>Java虚拟机规范规定，如果在堆上没有内存完成实例分配，并且堆上也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
</li>
<li><p>内存泄露和内存溢出<br>Java堆内存的OOM异常是非常常见的异常情况，重点是根据内存中的对象是否是必要的，来弄清楚到底是出现了内存泄露(Memory Leak)还是内存溢出(Memory Overflow).</p>
<ol>
<li>内存泄露：指程序中一些对象不会被GC所回收，它始终占用内存，即被分配的对象引用链可达但已无用。（可用内存减少）</li>
<li>内存溢出：程序运行过程中无法申请到足够的内存而导致的一种错误。内存溢出通常发生于OLD段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。内存泄露是内存溢出的一种诱因，不是唯一因素。</li>
</ol>
</li>
</ul>
<p>Q:是不是所有的JAVA对象都被分配到了JAVA堆上</p>
<p>A:并不,JAVA也有自己的逃逸算法和TLAB,<a href="http://blog.csdn.net/yangzl2008/article/details/43202969" target="_blank" rel="external">详情</a></p>
<p>Q:什么是GC机制</p>
<p>A:Garbage Collection，垃圾回收</p>
<p>注:</p>
<ol>
<li><p>Java虚拟机的内存管理。大体上分为两部分：垃圾回收算法和内存分配。举个不恰当的比喻，好比汽车的变速箱和发动机。当’转速/内存使用’过高时，就会触发’换挡/垃圾回收’。</p>
</li>
<li><p>Java虚拟机的内存分配，大体上可分为年轻代（Young Generation），老年代（Tenured Generation）以及元空间（Metaspace）。其中，新生代又分为Eden（伊甸园）,S0和S1（Survivor，幸存者乐园）。（参考《Java程序员修炼之道》及VisualVM）</p>
</li>
<li><p>Java 8取消了原来的永久代（PermGen），改为元空间（Metaspace）了。</p>
</li>
</ol>
<h2 id="JAVA方法区"><a href="#JAVA方法区" class="headerlink" title="JAVA方法区"></a>JAVA方法区</h2><ul>
<li><p>方法区也是被所有的线程共享的一块内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
</li>
<li><p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样 不需要连续的内存和可以选择固定大小或者可扩展之外，还可以选择不实现垃圾回收。<br>这区域的内存回收目标主要是针对常量池的回收和类型的卸载，一般而言，这个区域的内存回收比较难以令人满意，尤其是类型的回收，条件相当苛刻，但是这部分区域的内存回收确实是必要的。</p>
</li>
<li><p>Java虚拟机规范规定，当方法区无法满足内存分配的需求时，将抛出OutOfMemoryError异常。</p>
</li>
<li><p>运行时常量池是方法区的一部分。CLass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。<br>运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p>
</li>
<li><p>String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含了一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此字符串的引用。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </div><div class="line"> String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</div><div class="line"> System.out.println(str1.intern() == str1);</div><div class="line"></div><div class="line"> String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</div><div class="line"> System.out.println(str2.intern() == str2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注:这段代码在JDK1.6中运行，会得到两个false，而在JDK1.7中运行，会得到一个true和一个false。</p>
<p>原因是：</p>
<ul>
<li>在JDK1.6中intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是一个引用。<br>在JDK1.7中intern()方法不会复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的字符串实例是同一个。</li>
<li>str2返回false是因为Java这个字符串在执行StringBuilder(“ja”).append(“va”).toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合首次出现的原则，而”计算机软件”这个字符串是首次出现的。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java位运算]]></title>
      <url>http://gongly.cn/2016/10/23/java%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>留作备忘</p>
<a id="more"></a>
<p><a href="https://zhidao.baidu.com/question/354545410.html?skiptype=2" target="_blank" rel="external">移位运算</a></p>
<p><a href="http://blog.csdn.net/vebasan/article/details/6193916" target="_blank" rel="external">逻辑运算</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown语法总结]]></title>
      <url>http://gongly.cn/2016/10/23/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;留作参考</p>
<a id="more"></a>
<p><a href="http://blog.csdn.net/bendanban/article/details/44159903" target="_blank" rel="external">基本语法1</a></p>
<ul>
<li>使用标题</li>
<li>加粗、斜体</li>
<li>分割线</li>
<li>列表</li>
<li>引用</li>
</ul>
<p><a href="http://blog.csdn.net/bendanban/article/details/44179247" target="_blank" rel="external">基本语法2</a></p>
<ul>
<li>插入图片</li>
<li>代码</li>
<li>表格</li>
<li>超链接</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法和数据结构的关系]]></title>
      <url>http://gongly.cn/2016/10/23/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p>一位数据痴迷者的介绍</p>
<a id="more"></a>
<p><a href="https://zhidao.baidu.com/question/1945941327167439628.html?skiptype=2" target="_blank" rel="external">原文连接</a></p>
<p>本人乃一个数据痴迷者,在计算机的道路上,也是一个数据结构的痴迷者,现在大学里面和同学搞开发也痴迷于数据库,我就我个人的理解给你谈一谈:<br>首先,数据结构是一门计算机语言学的基础学科，它不属于任何一门语言，其体现的是几乎所有标准语言的算法的思想。</p>
<p>上面的概念有一些模糊，我们现在来具体说一说，相信你门的数据结构使用的是一门具体的语言比如C/C++语言来说明，那是为了辅助的学习数据结构，而数据结构本身不属于任何语言（相信你把书上的程序敲到电脑里面是不能通过的吧，其只是描述了过程，要调试程序，还需要修改和增加一些东西）。你们的书上开始应该在讲究数据的物理存储结构/逻辑存储结构等概念，说明数据结构首先就是“数据的结构”，在内存上的存储方式，就是物理的存储结构，在程序使用人员的思想上它是逻辑的，比如：<br>你们在C/C++中学习到链表，那么链表是什么一个概念，你们使用指针制向下一个结点的首地址，让他们串联起来，形成一个接一个的结点，就像显示生活中的火车一样。而这只是对于程序员的概念，但是在内存中存储的方式是怎样的那？对于你程序员来说这是“透明”的，其内部分配空间在那里，都是随机的，而内存中也没有一个又一根的线将他们串联起来，所以，这是一个物理与逻辑的概念，对于我们程序员只需要知道这些就可以了，而我们主要要研究的是“逻辑结构”。</p>
<p>我可以给你一个我自己总结的一个概念：所有的算法必须基于数据结构生存。也就是说，我们对于任何算法的编写，必须依赖一个已经存在的数据结构来对它进行操作，数据结构成为算法的操作对象，这也是为什么算法和数据结构两门分类不分家的概念，算法在没有数据结构的情况下，没有任何存在的意义；而数据结构没有算法就等于是一个尸体而没有灵魂。</p>
<p>估计这个对于算法的初学者可能有点晕，我们在具体的说一些东西吧：<br>我们在数据结构中最简单的是什么：我个人把书籍中线性表更加细化一层（这里是为了便于理解在这样说的）：单个元素，比如：int i;这个i就是一个数据结构，它是一个什么样的数据结构，就是一个类型为int的变量，我们可以对它进行加法/减法/乘法/除法/自加等等一系列操作，当然对于单个元素我们对它的数据结构和算法的研究没有什么意义，因为它本来就是原子的，某些具体运算上可能算法存在比较小的差异；而提升一个层次：就是我们的线性表（一般包含有：顺序表/链表）那么我们研究这样两种数据结构主要就是要研究它的什么东西那？一般我们主要研究他们以结构为单位（就是结点）的增加/删除/修改/检索（查询）四个操作（为什么有这样的操作，我在下面说到），我们一般把“增加/删除/修改”都把它称为更新，对于一个结点，若要进行更新一类的操作比如：删除，对于顺序表来说是使用下标访问方式，那么我们在删除了一个元素后需要将这个元素后的所有元素后的所有元素全部向前移动，这个时间是对于越长的顺序表，时间越长的，而对于链表，没有顺序的概念，其删除元素只需要将前一个结点的指针指向被删除点的下一个结点，将空间使用free()函数进行释放，还原给操作系统。当执行检索操作的时候，由于顺序表直接使用下标进行随机访问，而链表需要从头开始访问一一匹配才可以得到使用的元素，这个时间也是和链表的结点个数成正比的。所以我们每一种数据结构对于不同的算法会产生不同的效果，各自没有绝对的好，也没有绝对的不好，他们都有自己的应用价值和方式；这样我们就可以在实际的项目开发中，对于内部的算法时间和空间以及项目所能提供的硬件能力进行综合评估，以让自己的算法能够更加好。（在这里只提到了基于数据结构的一个方面就是：速度，其实算法的要素还应该包括：稳定性、健壮性、正确性、有穷性、可理解性、有输入和输出等等）</p>
<p>为什么要以结点方式进行这些乱七八糟的操作那？首先明确一个概念就是：对于过程化程序设计语言所提供的都是一些基础第一信息，比如一些关键字/保留字/运算符/分界符。而我们需要用程序解决现实生活中的问题，比如我们要程序记录某公司人员的情况变化，那么人员这个数据类型，在程序设计语言中是没有的，那么我们需要对人员的内部信息定义（不可能完全，只是我们需要那些就定义那些），比如：年龄/性别/姓名/出生日期/民族/工作单位/职称/职务/工资状态等，那么就可以用一些C/C++语言描述了，如年龄我们就可以进行如下定义:<br>int age;/<em>age变量，表示人员公司人员的年龄</em>/<br>同理进行其他的定义，我们用结构体或类把他们封装成自定义数据类型或类的形式，这样用他们定义的就是一个人的对象的了，它内部包含了很多的模板数据了。</p>
<p>我就我个人的经历估计的代码量应该10000以内的（我个人的经理：只是建议，从你的第一行代码开始算，不论程序正确与否，不论那一门语言，作为一个标准程序员需要十万行的代码的功底（这个是我在大学二年级感觉有一定时候的大致数据，不一定适合其他人），而十万行代码功底一般需要四门基础远支撑，若老师没有教，可以自学一些语言）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java线程总结]]></title>
      <url>http://gongly.cn/2016/09/25/JAVAThread/</url>
      <content type="html"><![CDATA[<h2 id="创建线程的两种方法"><a href="#创建线程的两种方法" class="headerlink" title="创建线程的两种方法"></a>创建线程的两种方法</h2><h3 id="通过实现Runnable接口线程创建"><a href="#通过实现Runnable接口线程创建" class="headerlink" title="通过实现Runnable接口线程创建"></a>通过实现Runnable接口线程创建</h3><ol>
<li>定义一个类实现Runnable接口，重写接口中的run()方法。在run()方法中加入具体的任务代码或处理逻辑。</li>
<li>创建Runnable接口实现类的对象。</li>
<li>创建一个Thread类的对象，需要封装前面Runnable接口实现类的对象。（接口可以实现多继承）</li>
<li>调用Thread对象的start()方法，启动线程<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadDemo1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">10</span>;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="comment">// 在run方法中定义任务  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>) &#123;  </div><div class="line">            System.out.println(<span class="string">"#"</span> + Thread.currentThread().getName() + <span class="string">"("</span>  </div><div class="line">                    + countDown + <span class="string">")"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="comment">// Runnable中run方法是一个空方法，并不会产生任何线程行为，必须显式地将一个任务附着到线程上  </span></div><div class="line">        TreadDemo1 tt=<span class="keyword">new</span> TreadDemo1();  </div><div class="line">        <span class="keyword">new</span> Thread(tt).start();  </div><div class="line">        <span class="keyword">new</span> Thread(tt).start();  </div><div class="line">        System.out.println(<span class="string">"火箭发射前倒计时："</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>运行结果：<br>火箭发射前倒计时：<br>Thread-1(8)<br><br>Thread-1(7)<br><br>Thread-1(6)<br><br>Thread-1(5)<br><br>Thread-1(4)<br><br>Thread-1(3)<br><br>Thread-1(2)<br><br>Thread-1(1)<br><br>Thread-1(0)<br><br>Thread-0(9)<br></p>
<h3 id="通过继承Thread类创建线程"><a href="#通过继承Thread类创建线程" class="headerlink" title="通过继承Thread类创建线程"></a>通过继承Thread类创建线程</h3><ol>
<li>首先定义一个类去继承Thread父类，重写父类中的run()方法。在run()方法中加入具体的任务代码或处理逻辑。</li>
<li>直接创建一个ThreadDemo2类的对象，也可以利用多态性，变量声明为父类的类型。</li>
<li>调用start方法，线程t启动，隐含的调用run()方法。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> countDown = <span class="number">10</span>;  </div><div class="line">  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="comment">// 在run方法中定义任务  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">while</span> (countDown-- &gt; <span class="number">0</span>) &#123;  </div><div class="line">            System.out.println(<span class="string">"#"</span> + <span class="keyword">this</span>.getName() + <span class="string">"("</span> + countDown + <span class="string">")"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">new</span> ThreadDemo2().start();  </div><div class="line">        <span class="keyword">new</span> ThreadDemo2().start();  </div><div class="line">        <span class="comment">// 由于start方法迅速返回，所以main线程可以执行其他的操作,此时有两个独立的线程在并发运行  </span></div><div class="line">        System.out.println(<span class="string">"火箭发射前倒计时："</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><br>Thread-0(9)<br><br>Thread-0(8)<br><br>Thread-0(7)<br><br>Thread-0(6)<br><br>Thread-0(5)<br><br>Thread-0(4)<br><br>Thread-0(3)<br><br>Thread-0(2)<br><br>Thread-0(1)<br><br>Thread-0(0)<br>火箭发射前倒计时：<br><br>Thread-1(9)<br><br>Thread-1(8)<br><br>Thread-1(7)<br><br>Thread-1(6)<br><br>Thread-1(5)<br><br>Thread-1(4)<br><br>Thread-1(3)<br><br>Thread-1(2)<br><br>Thread-1(1)<br><br>Thread-1(0)</p>
<h3 id="两种方式的比较"><a href="#两种方式的比较" class="headerlink" title="两种方式的比较"></a>两种方式的比较</h3><p>首先分析两种方式的输出结果，同样是创建了两个线程，为什么结果不一样呢？<br><br>使用实现Runnable接口方式创建线程可以共享同一个目标对象（TreadDemo1 tt=new TreadDemo1();），实现了多个相同线程处理同一份资源。<br><br><br>然后再看一段来自JDK的解释：<br><br>Runnable 接口应该由那些打算通过某一线程执行其实例的类来实现。类必须定义一个称为run 的无参数方法。<br>设计该接口的目的是为希望在活动时执行代码的对象提供一个公共协议。例如，Thread 类实现了Runnable。激活的意思是说某个线程已启动并且尚未停止。<br><br><br>此外，Runnable 为非 Thread 子类的类提供了一种激活方式。通过实例化某个Thread 实例并将自身作为运行目标，就可以运行实现 Runnable 的类而无需创建 Thread 的子类。大多数情况下，如果只想重写run() 方法，而不重写其他 Thread 方法，那么应使用 Runnable 接口。这很重要，因为除非程序员打算修改或增强类的基本行为，否则不应为该类创建子类。</p>
<p>采用继承Thread类方式：<br><br>（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。<br><br>（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。<br>采用实现Runnable接口方式：<br><br>（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。在这种方式下，可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。<br><br>（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Eclipse的常用快捷键【备忘】]]></title>
      <url>http://gongly.cn/2016/09/24/eclipse%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<p>Ctrl+K 光标放在一个变量上(注意,是变量,如果你的光标放在了字符串上,则没有任何作用的),按下Ctrl+K光标会定位到下一个相同的变量<br><br>Shift+Ctrl+K 跟Ctrl+K功能一样,方向相反<br><br>Ctrl+O 打开类似大纲视图的小窗口<br><br>Alt+ 左右方向键,跳到前一次/后一次的编辑位置<br><br>双击左括号(小括号,中括号,大括号),将选择括号内的所有内容<br><br>F3打开声明该引用的文件1</p>
<a id="more"></a>
<p><br>F4打开类型层次结构<br><br>Ctrl+H打开搜索窗口<br><br>Shift+Ctrl+S保存全部<br><br>Shift+Ctrl+R打开资源<br><br>Ctrl+Q回到最后一次编辑的地方<br><br>Ctrl+Shift+G在workspace中搜索引用<br><br>Alt+上、下方向键,将选中的行向上或向下移动<br><br>Shift+Enter在当前行的下面添加一个空行,光标可以当前行的任意位置<br><br>Ctrl+L跳转到某行<br><br>Ctrl+M最大化当前的Edit或View,再按则反之<br><br>Ctrl+/注释当前行,再按则反之<br><br>Ctrl+T显示当前类的继承情况(可以查看类的目录树)<br><br>Ctrl+E显示当前Edit的下拉列表<br><br>Ctrl+/(小键盘) 折叠当前类中的所有代码<br><br>Ctrl+*(小键盘) 展开当前类中的所有代码<br><br>Alt+/代码助手,提示代码<br><br>Ctrl+J正向增量查找<br><br>Ctrl+Shift+J反向增量查找<br><br>Ctrl+Shift+F4关闭所有打开的edit<br><br>Ctrl+Shift+R查找文件<br><br>Ctrl+Shift+T查找类<br><br>Alt+Shift+R重名命<br><br>Alt+Shift+M抽取方法<br><br>Alt+Shift+Z取消重构</p>
]]></content>
    </entry>
    
  
  
</search>
